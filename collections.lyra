(when (not (defined? 'lyra-core-collections-loaded))

(define lyra-core-collections-loaded #t)

(define (first x) ((find-type-fn x 'first) x))
(define (second x) ((find-type-fn x 'second) x))
(define (third x) ((find-type-fn x 'third) x))
(define (rest x) ((find-type-fn x 'rest) x))
(define (set-at x i e) ((find-type-fn x 'set-at) x i e))

(define (size x) (let* (f (find-type-fn x 'size)) (if f (f x) '())))
(define (empty? x) (let* (f (find-type-fn x 'empty?)) (if f (f x) #f)))
(define (eq? x y) (let* (f (find-type-fn x 'eq?)) (if f (f x y) (= x y))))
(define (nth x i)  (let* (f (find-type-fn x 'nth)) (if f (f x i) '())))
(define (foldl f s x) ((find-type-fn x 'foldl) f s x))
(define (map f x) ((find-type-fn x 'map) f x))
(define (filter p x) ((find-type-fn x 'filter) p x))
(define (append x y) ((find-type-fn x 'append) x y))
(define (find-first p x) ((find-type-fn x 'find-first) p x))
(define (->string x)
  (let* (f (find-type-fn x '->string))
    (if f (f x) (_string x))))
(define (->vector x) ((find-type-fn x '->vector) x))
(define (->list x) ((find-type-fn x '->list) x))
(define (copy x) ((find-type-fn x 'copy) x))
(define (but-last x) ((find-type-fn x 'but-last) x))
(define (reverse x) ((find-type-fn x 'reverse) x))
(define (map-while f p x) ((find-type-fn x 'map-while) f p x))
(define (map-until f p x) ((find-type-fn x 'map-until) f p x))
(define (take n x) ((find-type-fn x 'take) n x))
(define (drop n x) ((find-type-fn x 'drop) n x))
(define (take-while p x) ((find-type-fn x 'take-while) p x))
(define (take-until p x) ((find-type-fn x 'take-until) p x))
(define (drop-while p x) ((find-type-fn x 'drop-while) p x))
(define (drop-until p x) ((find-type-fn x 'drop-until) p x))
(define (zip x y) ((find-type-fn x 'zip) x y))

)
