(define (load! f)
  (eval! (parse (slurp! f))))

(def-macro (comment & e) '())

(define (id e) e)

(define (inc x) (+ x 1))
(define (dec x) (- x 1))

(define (even? x) (= (% x 2) 0))
(define (odd? x) (= (% x 2) 1))

(define (min x y) (if (< x y) x y))
(define (max x y) (if (> x y) x y))

(define (list & xs) xs)
(define car _car)
(define cdr _cdr)

(define (box-swap! b f) (box-set! b (f (unbox b))))

(def-macro (not x) (list 'if x #f #t))

(def-macro (or & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        #t
        (cons or (cdr xs)))))

(def-macro (and & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        (cons and (cdr xs))
        #f)))

(define (wrap1 e) (lambda (x) e))
(define always-null (wrap1 '()))
(define always-true (wrap1 #t))
(define always-false (wrap1 #f))

(define (negate p) (lambda (x) (not (p e))))

(def-macro (begin & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        (cons begin (cdr xs))
        (cons begin (cdr xs)))))

(def-macro (when p & xs)
  (list 'if p (cons begin xs) '()))

(let* (gen-sym-counter (box 19980629))
  (define (gensym)
    (box-set! gen-sym-counter (inc (unbox gen-sym-counter)))
    (symbol (_string "_gensym_" (unbox gen-sym-counter)))))

(define (string & xs)
  (if (null? xs)
    ""
    (_string (->string (car xs)) (apply string (cdr xs)))))

(define (println! x)
  (_println! (->string x)))


(load! "type.lyra")
(load! "maybe.lyra")
(load! "collections.lyra")
(load! "list.lyra")
(load! "vector.lyra")


(comment
(define (type-tree-insert top name fn)
  (if (not top)
    (vector name fn '() '())
    (let* (top-name (_vector-get top 0))
      (cond ((= top-name name)
              [top-name fn (_vector-get top 2) (_vector-get top 3)])
            ((< top-name name)
              [top-name (_vector-get top 1) (_vector-get top 2) (type-tree-insert (_vector-get top 3) name fn)])
            (#t
              [top-name (_vector-get top 1) (type-tree-insert (_vector-get top 2) name fn) (_vector-get top 3)])))))

(define (get-fn top name)
  (if (not top)
    '()
    (let* (top-name (_vector-get top 0))
      (cond ((= top-name name) (_vector-get top 1))
            ((> top-name name) (get-fn (_vector-get top 2) name))
            (#t (get-fn (_vector-get top 3) name))))))

(let ((t0 (type-tree-insert '() 'bar _string))
      (t1 (type-tree-insert t0 'foo inc)))
  (_println! (_string (get-fn '() 'bar)))
  (_println! (_string (get-fn t0 'bar)))
  (_println! (_string (get-fn t1 'bar)))
  (_println! (_string (get-fn '() 'foo)))
  (_println! (_string (get-fn t0 'foo)))
  (_println! (_string (get-fn t1 'foo)))
  (_println! (_string t0))
  (_println! (_string t1))
  )
(comment let ((t0 (type-tree-insert '() "bar" _string))
      (t1 (type-tree-insert t0 "foo" inc)))
  (_println! (_string (get-fn '() "bar")))
  (_println! (_string (get-fn t0 "bar")))
  (_println! (_string (get-fn t1 "bar")))
  (_println! (_string (get-fn '() "foo")))
  (_println! (_string (get-fn t0 "foo")))
  (_println! (_string (get-fn t1 "foo")))
  )
(comment let* (t (fn-ins (fn-ins '() 'foo _string) 'foo inc))
  (_println! (_string t))
  (_println! (_string (fn-find t 'foo)))
  (_println! (_string (fn-find t 'bar)))
  (_println! (_string (fn-find t 'baz))))
)

'lyra-core-loaded
