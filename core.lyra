(define lyra-core-loaded #t)

(define (load! f)
  (eval! (parse (slurp! f))))

(def-macro (comment & e) '())

(define (id e) e)

(define (inc x) (+ x 1))
(define (dec x) (- x 1))

(define (even? x) (= (% x 2) 0))
(define (odd? x) (= (% x 2) 1))

(define (list & xs) xs)
(define car _car)
(define cdr _cdr)

(define (box-swap! b f) (box-set! b (f (unbox b))))

(def-macro (not x) (list 'if x #f #t))

(def-macro (or & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        #t
        (cons or (cdr xs)))))

(def-macro (and & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        (cons and (cdr xs))
        #f)))

(define (always-true e) #t)
(define (always-false e) #f)

(def-macro (begin & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        (cons begin (cdr xs))
        (cons begin (cdr xs)))))

(def-macro (when p & xs)
  (list 'if p (cons begin xs) '()))

(let* (gen-sym-counter (box 19980629))
  (define (gensym)
    (box-set! gen-sym-counter (inc (unbox gen-sym-counter)))
    (symbol (_string "_gensym_" (unbox gen-sym-counter)))))

(define (string & xs)
  (if (empty? xs)
    ""
    (_string (->string (car xs)) (apply string (cdr xs)))))

(define (println! x)
  (_println! (->string x)))

(load! "type.lyra")
(load! "maybe.lyra")
(load! "collections.lyra")
(load! "list.lyra")
(load! "vector.lyra")
