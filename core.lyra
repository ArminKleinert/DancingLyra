(define lyra-core-loaded #t)

(define (load! f)
  (eval! (parse (slurp! f))))

(def-macro (comment & e) '())

(define (id e) e)

(define (inc x) (+ x 1))
(define (dec x) (- x 1))

(define (even? x) (= (% x 2) 0))
(define (odd? x) (= (% x 2) 1))

(define (list & xs) xs)
(define car _car)
(define cdr _cdr)

(define (box-swap! b f) (box-set! b (f (unbox b))))

(def-macro (not x) (list 'if x #f #t))

(def-macro (or & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        #t
        (cons or (cdr xs)))))

(def-macro (and & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        (cons and (cdr xs))
        #f)))

(define (always-true e) #t)
(define (always-false e) #f)

(def-macro (begin & xs)
  (if (not (cdr xs))
    (car xs)
    (list
      'if (car xs)
        (cons begin (cdr xs))
        (cons begin (cdr xs)))))

(def-macro (when p & xs)
  (list 'if p (cons begin xs) '()))

(let* (gen-sym-counter (box 19980629))
  (define (gensym)
    (box-set! gen-sym-counter (inc (unbox gen-sym-counter)))
    (symbol (_string "_gensym_" (unbox gen-sym-counter)))))

(define (string & xs)
  (if (empty? xs)
    ""
    (_string (->string (car xs)) (apply string (cdr xs)))))

(define (println! x)
  (_println! (->string x)))

(load! "type.lyra")
(load! "maybe.lyra")
(load! "collections.lyra")
(load! "list.lyra")
(load! "vector.lyra")

(comment

(def-generic xs (foldr f e xs) foldl)

(def-method cons-id foldr (list-foldr f e xs)
  (if (null? xs)
    e
    (f (car xs) (list-foldr f e (cdr xs)))))

(println! (foldr + 0 '(1 2 3 4 5)))

(_println! (macro-expand (def-generic xs (foldr f e xs) foldl)))
(_println! (macro-expand (def-method cons-id foldr (list-foldr f e xs)
  (if (null? xs)
    e
    (f (car xs) (list-foldr f e (cdr xs)))))))

(println! (macro-expand (or #t #f #t)))

(println! (or #f #f #f))
(println! (or #f #f #t))
(println! (or #f #t #f))
(println! (or #f #t #t))
(println! (or #t #f #f))
(println! (or #t #f #t))
(println! (or #t #t #f))
(println! (or #t #t #t))
(println! "")
(println! (and #f #f #f))
(println! (and #f #f #t))
(println! (and #f #t #f))
(println! (and #f #t #t))
(println! (and #t #f #f))
(println! (and #t #f #t))
(println! (and #t #t #f))
(println! (and #t #t #t))

(let* (m (maybe 4))
  (println! m)
  (println! m.?)
  (println! nothing)
)

(when #t (println! 1))
(when #t (println! 1) (println! 2))
(when #t (println! 1) (println! 2) (println! 3) (println! 4))
(when #f (println! 1) (println! 2))

(println! (apply vector 1 2 3 '(3 4 5)))
(println! (apply string '(3 4 5)))

(println! (add-type-fn! nil-id 'a (lambda (x) 67890)))
(println! (find-type-fn '() 'a))
(println! (empty? '()))
(println! (empty? '(1)))
(println! (empty? [1]))
(println! (empty? []))


(println! "")

(println! (comment e a b))

(println! (vector-set [1 2 3] 1 5)) ; Expected: [1 5 3]
(println! (vector-set [9 9 9] 2 4)) ; Expected: [9 9 4]
(println! (vector-set [1 1 1 1 1 1 1 1] 6 17)) ; Expected: [1 1 1 1 1 1 17 1]

(println! (cdr (list 9 8 7 6)))
;(println! (associated (list (cons 1 2) (cons 3 4) (cons 5 6) (cons 7 8) (cons 9 10)) 1))
;(println! (associated (list (cons 1 2) (cons 3 4) (cons 5 6) (cons 7 8) (cons 9 10)) 3))
;(println! '((1 2) (3 4) (5 6) (7 8) (9 10)))

(println! "")

(println! add-type-fn!)
(println! (add-type-fn! nil-id 'a (lambda (x) 67890)))
(println! (find-type-fn '() 'true?))
(println! (find-type-fn '() 'a))
(println! ((find-type-fn '() 'a) '()))

(println! (string "abc " 'def " " 1 " " 0.5 " " begin " " id " " '() " " (list 1 2 3) " " [1 2 3] " " #t " " #f))
)
