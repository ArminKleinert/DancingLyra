(define lyra-core-loaded #t)

(define (load! f)
  (eval! (parse (slurp! f))))

(def-macro (comment & e) '())

(define (id e) e)

(def-macro (or x y) (list 'if x #t y))
(def-macro (and x y) (list 'if x y #f))
(def-macro (not x) (list 'if x #f #t))

(define (inc x) (+ x 1))
(define (dec x) (- x 1))

(define (even? x) (= (% x 2) 0))
(define (odd? x) (= (% x 2) 1))

(define (list & xs) xs)
(define car _car)
(define cdr _cdr)

(define (always-true e) #t)
(define (always-false e) #f)

(define _types (box []))
(define (box-swap! b f)(box-set! b (f (unbox b))))

(define (add-type!)
  (box-swap! _types (lambda (x) (_vector-append x '())))
  (- (_vector-size (unbox _types)) 1))

(define (associated xs sym)
  (if (null? xs)
    '()
    (if (= (car (car xs)) sym) (car (cdr (car xs))) (associated (cdr xs) sym))))

(define (find-type-fn x sym)
  (associated
    (_vector-get (unbox _types) (lyra-type-id x))
    sym))

(let* (vector-set (lambda (v idx xyz)
  (_vector-iterate v []
    (lambda (acc e i)
      (if (= i idx) (_vector-append acc xyz) (_vector-append acc e))))))

  (define (add-type-fn! type sym f)
    (let* (v (unbox _types))
      (box-set! _types
        (vector-set
          v type
          (cons
            (list sym f)
            (_vector-get v type))))
      type))

  (define (add-type-fns! type sym-to-f-list)
    (let* (list-append1
            (lambda (l0 l1)
              (if (null? l0)
                l1
                (cons (car l0) (list-append1 (cdr l0) l1)))))
      (let* (v (unbox _types))
        (box-set! _types
          (vector-set
            v type
            (list-append1
              sym-to-f-list
              (_vector-get v type))))
        type)))
)

(define nil-id    (add-type!))
(define symbol-id (add-type!))
(define string-id (add-type!))
(define char-id   (add-type!))
(define fixnum-id (add-type!))
(define real-id   (add-type!))
(define cons-id   (add-type!))
(define func-id   (add-type!))
(define bool-id   (add-type!))
(define vector-id (add-type!))
(define box-id    (add-type!))
(define _unused-id (add-type!))

(define (null? x) (= (lyra-type-id x) nil-id))
(define (symbol? x) (= (lyra-type-id x) symbol-id))
(define (string? x) (= (lyra-type-id x) string-id))
(define (char? x) (= (lyra-type-id x) char-id))
(define (integer? x) (= (lyra-type-id x) fixnum-id))
(define (real? x) (= (lyra-type-id x) real-id))
(define (cons? x) (= (lyra-type-id x) cons-id))
(define (func? x) (= (lyra-type-id x) func-id))
(define (bool? x) (= (lyra-type-id x) bool-id))
(define (box? x) (= (lyra-type-id x) box-id))
(define (number? x) (let* (f (find-type-fn x 'number?)) (if f (f x) (or (integer? x) (real? x)))))

(define (list? x) (let* (f (find-type-fn x 'list?)) (if f (f x) #f)))
(define (vector? x) (let* (f (find-type-fn x 'vector?)) (if f (f x) #f)))

(define (first x) ((find-type-fn x 'first) x))
(define (second x) ((find-type-fn x 'second) x))
(define (third x) ((find-type-fn x 'third) x))
(define (rest x) ((find-type-fn x 'rest) x))
(define (set-at x i e) ((find-type-fn x 'set-at) x i e))

(define (size x) (let* (f (find-type-fn x 'size)) (if f (f x) '())))
(define (empty? x) (let* (f (find-type-fn x 'empty?)) (if f (f x) #f)))
(define (eql? x y) (let* (f (find-type-fn x 'eql?)) (if f (f x y) (= x y))))
(define (eq? x y) (let* (f (find-type-fn x 'eq?)) (if f (f x y) (= x y)))) ; TODO: Make this the default name!
(define (nth x i)  (let* (f (find-type-fn x 'nth)) (if f (f x i) '())))
(define (foldl f s x) ((find-type-fn x 'foldl) f s x))
(define (map f x) ((find-type-fn x 'map) f x))
(define (filter p x) ((find-type-fn x 'filter) p x))
(define (append x y) ((find-type-fn x 'append) x y))
(define (find-first p x) ((find-type-fn x 'find-first) p x))
(define (->string x)
  (let* (f (find-type-fn x '->string))
    (if f (f x) (_string x))))
(define (->vector x) ((find-type-fn x '->vector) x))
(define (->list x) ((find-type-fn x '->list) x))
(define (copy x) ((find-type-fn x 'copy) x))
(define (but-last x) ((find-type-fn x 'but-last) x))
(define (reverse x) ((find-type-fn x 'reverse) x))
(define (map-while f p x) ((find-type-fn x 'map-while) f p x))
(define (map-until f p x) ((find-type-fn x 'map-until) f p x))
(define (take n x) ((find-type-fn x 'take) n x))
(define (drop n x) ((find-type-fn x 'drop) n x))
(define (take-while p x) ((find-type-fn x 'take-while) p x))
(define (take-until p x) ((find-type-fn x 'take-until) p x))
(define (drop-while p x) ((find-type-fn x 'drop-while) p x))
(define (drop-until p x) ((find-type-fn x 'drop-until) p x))
(define (zip x y) ((find-type-fn x 'zip) x y))

(def-macro (begin & xs)
  (if (null? (cdr xs))
    (car xs)
    (list
      'if (car xs)
        (cons begin (cdr xs))
        (cons begin (cdr xs)))))

(def-macro (when p & xs)
  (list 'if p (cons begin xs) '()))

(define (string & xs)
  (if (empty? xs)
    ""
    (_string (->string (car xs)) (apply string (cdr xs)))))

(define (println! x)
  (_println! (->string x)))

(load! "list.lyra")
(load! "vector.lyra")

(comment

(when #t (println! 1))
(when #t (println! 1) (println! 2))
(when #t (println! 1) (println! 2) (println! 3) (println! 4))
(when #f (println! 1) (println! 2))

(println! (apply vector 1 2 3 '(3 4 5)))
(println! (apply string '(3 4 5)))

(println! (string "(&& #t #t #t)" (&& #t #t #t)))
(println! (string "(&& #t #t #f)" (&& #t #t #f)))
(println! (string "(&& #t #f #t)" (&& #t #f #t)))
(println! (string "(&& #t #f #f)" (&& #t #f #f)))
(println! (string "(&& #f #t #t)" (&& #f #t #t)))
(println! (string "(&& #f #t #f)" (&& #f #t #f)))
(println! (string "(&& #f #f #t)" (&& #f #f #t)))
(println! (string "(&& #f #f #f)" (&& #f #f #f)))
(println! (&& #f (println! "SHOULD NOT BE HERE!")))
(println! (&& #f #f (println! "SHOULD NOT BE HERE!")))
(println! (&& #f #f #f (println! "SHOULD NOT BE HERE!")))

(println! (add-type-fn! nil-id 'a (lambda (x) 67890)))
(println! (find-type-fn '() 'a))
(println! (empty? '()))
(println! (empty? '(1)))
(println! (empty? [1]))
(println! (empty? []))


(println! "")

(println! (comment e a b))

(println! (vector-set [1 2 3] 1 5)) ; Expected: [1 5 3]
(println! (vector-set [9 9 9] 2 4)) ; Expected: [9 9 4]
(println! (vector-set [1 1 1 1 1 1 1 1] 6 17)) ; Expected: [1 1 1 1 1 1 17 1]

(println! (cdr (list 9 8 7 6)))
;(println! (associated (list (cons 1 2) (cons 3 4) (cons 5 6) (cons 7 8) (cons 9 10)) 1))
;(println! (associated (list (cons 1 2) (cons 3 4) (cons 5 6) (cons 7 8) (cons 9 10)) 3))
;(println! '((1 2) (3 4) (5 6) (7 8) (9 10)))

(println! "")

(println! add-type-fn!)
(println! (add-type-fn! nil-id 'a (lambda (x) 67890)))
(println! (find-type-fn '() 'true?))
(println! (find-type-fn '() 'a))
(println! ((find-type-fn '() 'a) '()))

(println! (string "abc " 'def " " 1 " " 0.5 " " begin " " id " " '() " " (list 1 2 3) " " [1 2 3] " " #t " " #f))
)
