(define (caar x)    (car (car x)))
(define (cadr x)    (car (cdr x)))
(define (cdar x)    (cdr (car x)))
(define (cddr x)    (cdr (cdr x)))
(define (caaar x)   (car (car (car x))))
(define (caadr x)   (car (car (cdr x))))
(define (cadar x)   (car (cdr (car x))))
(define (caddr x)   (car (cdr (cdr x))))
(define (cdaar x)   (cdr (car (car x))))
(define (cdadr x)   (cdr (car (cdr x))))
(define (cddar x)   (cdr (cdr (car x))))
(define (cdddr x)   (cdr (cdr (cdr x))))
(define (caaaar x)  (car (car (car (car x)))))
(define (caaadr x)  (car (car (car (cdr x)))))
(define (caadar x)  (car (car (cdr (car x)))))
(define (caaddr x)  (car (car (cdr (cdr x)))))
(define (cadaar x)  (car (cdr (car (car x)))))
(define (cadadr x)  (car (cdr (car (cdr x)))))
(define (caddar x)  (car (cdr (cdr (car x)))))
(define (cadddr x)  (car (cdr (cdr (cdr x)))))
(define (cdaaar x)  (cdr (car (car (car x)))))
(define (cdaadr x)  (cdr (car (car (cdr x)))))
(define (cdadar x)  (cdr (car (cdr (car x)))))
(define (cdaddr x)  (cdr (car (cdr (cdr x)))))
(define (cddaar x)  (cdr (cdr (car (car x)))))
(define (cddadr x)  (cdr (cdr (car (cdr x)))))
(define (cdddar x)  (cdr (cdr (cdr (car x)))))
(define (cddddr x)  (cdr (cdr (cdr (cdr x)))))

(define (list-empty? l) (null? l))

(define (list->string l)
  (if (list-empty? l)
    ""
    (string (->string (car l)) (cdr l))))

(define (list-eql? x y)
  (if (list? y)
    (let* (list-eql1?
            (lambda (l0 l1) (if (list-empty? l0)
              (list-empty? l1)
              (and (eql? (car l0) (car l1)) (list-eql1? (cdr l0) (cdr l1))))))
      (list-eql1? x y))
    #f))

; TODO Tests
(define (list-nth xs index)
  (if xs
    (if (= index 0)
      (car xs)
      (list-nth (cdr xs) (- index 1)))
    '()))

(define (list-foldl f start coll)
  (if (list-empty? coll)
    start
    (list-foldl f (f start (car coll)) (cdr coll))))

; TODO Tests
(define (list-map f xs)
  (if (list-empty? xs)
    '()
    (cons (f (car xs)) (list-map f (cdr xs)))))

; TODO Tests
(define (list-filter f xs)
  (if (list-empty? xs)
    '()
    (if (f (car xs))
      (cons (car xs) (list-filter f (cdr xs)))
      (list-filter f (cdr xs)))))

; TODO Tests
(define (list-append c0 c1)
  (if (null? c0)
    (->list c1)
    (cons (car c0) (list-append (cdr c0) c1))))

; TODO Tests
(define (list-find-first f l)
  (cond ((list-empty? l) '())
        ((f (car l)) (car l))
        (#t (list-find-first f (cdr l)))))

; TODO Tests
(define (list->vector ls)
  (foldl (lambda (v x) (_vector-append v x))
         (vector) ls))

; TODO Tests
(define (list-copy c)
  c)

; TODO Tests
(define (list-but-last c0)
  (cond ((null? c0) '())
        ((null? (cdr c0)) '())
        (#t (cons (car c0) (list-but-last (cdr c0))))))

; TODO Tests
(define (list-reverse xs)
  (foldl
    (lambda (res e) (cons e res))
    '() xs))

; TODO Tests
(define (list-map-while f p c)
  (cond ((list-empty? c) c)
        ((p (car c)) (cons c (list-map-while f p (cdr c))))
        #t '()))

; TODO Tests
(define (list-map-until f p c)
  (cond ((list-empty? c) c)
        ((p (car c)) '())
        #t (cons c (list-map-until f p (cdr c)))))

; TODO Tests
(define (list-take-while p c)
  (if (or (list-empty? c) (not (p (car c))))
    '()
    (cons (car c) (list-take-while p (cdr c)))))

; TODO Tests
(define (list-take-until p c)
  (if (or (list-empty? c) (p (car c)))
    '()
    (cons (car c) (list-take-until p (cdr c)))))

; TODO Tests
(define (list-drop-while p c)
  (if (or (list-empty? c) (not (p (car c))))
    c
    (list-drop-while p (cdr c))))

; TODO Tests
(define (list-drop-until p c)
  (if (or (list-empty? c) (not (p (car c))))
    c
    (list-drop-until p (cdr c))))

; TODO Tests
(define (list-zip c0 c1)
  (let* (c2 (->list c1))
    (cond ((list-empty? c0) '())
          ((list-empty? c2) '())
          (#t (cons (cons (car c0) (car c2)) (list-zip c0 c2))))))

(add-type-fns! cons-id
  (list
    (list 'empty? always-false)
    (list 'eql? list-eql?)
    (list 'nth list-nth)
    (list 'foldl list-foldl)
    (list 'map list-map)
    (list 'filter list-filter)
    (list 'append list-append)
    (list 'find-first list-find-first)
    (list '->vector list->vector)
    (list '->list id)
    (list 'copy list-copy)
    (list 'but-last list-but-last)
    (list 'reverse list-reverse)
    (list 'map-while list-map-while)
    (list 'map-until list-map-until)
    (list 'take-while list-take-while)
    (list 'take-until list-take-until)
    (list 'drop-while list-drop-while)
    (list 'drop-until list-drop-until)
    (list 'zip list-zip)
    (list 'list? always-true)
    (list 'vector? always-false)))
  
(add-type-fns! nil-id
  (list
    (list 'empty? always-true)
    (list 'eql? (lambda (l0 l1) (= (lyra-type-id l0) (lyra-type-id l1))))
    (list 'nth list-nth)
    (list 'foldl list-foldl)
    (list 'map list-map)
    (list 'filter list-filter)
    (list 'append list-append)
    (list 'find-first list-find-first)
    (list '->vector list->vector)
    (list '->list id)
    (list 'copy list-copy)
    (list 'but-last list-but-last)
    (list 'reverse list-reverse)
    (list 'map-while list-map-while)
    (list 'map-until list-map-until)
    (list 'take-while list-take-while)
    (list 'take-until list-take-until)
    (list 'drop-while list-drop-while)
    (list 'drop-until list-drop-until)
    (list 'zip list-zip)
    (list 'list? always-false)
    (list 'vector? always-false)))

#t






























